This chapter describes the specific implementation details of the base IDDR system and the new IDDR system.

\section{Implementation Overview} 
We implemented the IDDR system with Linux kernel 3.5.0 and Xen hypervisor 4.2.1. In this implementation we isolate the block device driver from Linux kernel. The application domain and the driver domain run the same Linux kernel in the IDDR system. The Table~\ref{tab:base} and Table~\ref{tab:new} summarizes our implementation efforts of the base IDDR system and the new IDDR system respectively.

\begin{table}
\caption{The base IDDR system implementation efforts.}
\begin{center}
\begin{tabular}{ll}
  \hline
  \label{tab:base}
  Component & Number of Lines \\
  \hline
  Linux Kernel & 6 \\
  Xen & 252 \\
  Front-end Driver & 611 \\
  Back-end Driver & 692 \\
  \hline 
  Total & 1561\\
  \hline
\end{tabular}
\end{center}
\end{table}

\begin{table}
\caption{The new IDDR system implementation efforts.}
\begin{center}
\begin{tabular}{ll}
  \hline
  \label{tab:new}
  Component & Number of Lines \\
  \hline
  Linux Kernel & 6 \\
  Xen & 252 \\
  Front-end Driver & 712 \\
  Back-end Driver & 752 \\
  \hline 
  Total & 1722\\
  \hline
\end{tabular}
\end{center}
\end{table}

The IDDR system implementation did not require any changes to the device driver code. However, we did make small number of changes to the Xen and Linux kernel to implement a hypercall.

\section{Implementation}

Figure~\ref{fig:Implementation overview} shows the implementation overview of the new IDDR system.

\begin{figure}[!ht]
\centering
\includegraphics[scale=.5]{impl_overview_new}
\caption{Implementation overview of the new IDDR system}
\label{fig:Implementation overview}
\end{figure}

\subsection{Communication Component}
The most important component in the IDDR system implementation is the communication component. This section describes the implementation details of the communication channel of the base IDDR system and the new IDDR system. 
\subsubsection*{The base IDDR system}
As the Section~\ref{sub:communicationmodule} describes, the role of the communication module in the base IDDR system is:
\begin{enumerate} 
\item Share requests and responses between the driver domain and the application domain.
\item Share data of read/write requests/responses.
\item Notify the domain upon the availability of requests and responses. 
\end{enumerate}
\paragraph{Shared Request and Response Queue}
In order to implement the first role of the communication module, we use ring buffer mechanism provided by the Xen. Ring buffer is a shared I/O ring explained in section~\ref{subsec:io rings}. The part of the ring buffer which shares requests is called \textit{shared request queue}, and the part of queue which shares responses is called as \textit{shared response queue}. We divide the ring buffer into the front ring and the back ring. The IDDR system uses the front ring as the shared request queue and the back ring as the shared response queue. 
\\[3mm]
The IDDR system allocates the ring buffer in the initialization stage of the communication module and initializes the ring buffer as a front ring in the application domain. Whenever the frontend driver recieves a request from an application in the application domain, the frontend driver removes the request from the device driver queue and submits it to the communication module. The communication module checks for a free space in the shared request queue, and if available it allocates the space for the new request. After batching sufficient requests together, the communication module pushes all requests to the shared request queue.

\paragraph{Shared Memory for Read/Write Data}
The ring buffer canot hold the data of read responses and write requests. We use the ring buffer only to share requests and responses. In order to share actual data we use shared pages. 
\\[3mm]
As explained in Section~\ref{subsec:sharedpages}, a grant table is used for sharing memory between domains. We use grant table to share a memory between the application domain and the driver domain.
\\[3mm]
The frontend driver removes the request from the device driver queue in the application domain, and forwards it to the communication module. The communication module allocates a shared memory required to read the data from backend, or to write the data to backend. The communication module then grants the access to the driver domain. As the driver domain has a grant access to the shared memory, the backend driver can access the data from shared memory.

\paragraph{Event Notification}
Event channel is a mechanism provided by the Xen hypervisor for event notification. The communication module in the base IDDR system uses event channel to send notifications between domains to notify the availability of requests and responses in the shared request queue and the shared response queue. 
\\[3mm]
We create a new event channel in the initialization stage of the communication module in the application domain and connect to the same event channel in the initialization stage of the communication module in the driver domain. We attach an interrupt handle routine for the event channel in both application and driver domain. The interrupt handler routine in the application domain reads responses from the shared response queue and hands over to the frontend driver. The interrupt handler routine in the driver domain reads requests from the shared request queue and hands over to the backend driver.

\subsubsection*{New IDDR System}
As the Section~\ref{sub:communicationmodule} describes, the role of the communication module in the new IDDR system is:
\begin{enumerate} 
\item Share requests and responses between the driver domain and the application domain.
\item Share the data of read/write requests/responses.
\item Wake up the read request thread and the read response thread. 
\end{enumerate}
\paragraph{Shared Request and Response Queue}
Similar to the base IDDR system, the communication module uses a ring buffer to as the shared request and response queue. 

\paragraph{Shared Memory for Read/Write Data}
Similar to the base IDDR system, the communication module uses a grant table to share an allocated memory between the application domain and the driver domain. 

\paragraph{Threads and Event Notification}
In order to improve the performance of the IDDR system, we implement the communication module where a thread in the frontend driver spins for the availability of responses, and a thread in the backend driver spins for the availability of requests. In case of unavailability of requests and responses, both threads go to sleep. 
\\[3mm] 
The new IDDR system uses event channel to wake the read request thread sleeping in the application domain. The wake up signal is sent in from of an event channel notification from the driver domain to the application domain. Similarly, to wake the read response thread sleeping in the driver domain, an event channel notification is sent from the application domain to the driver domain.

\begin{itemize}
\item Read response thread in the application domain: 
In the new IDDR system we create a kernel thread \textit{read response thread} during an initialization stage of the communication module in the application domain. The thread spins to check if responses are available in the shared response queue. If a response is available, it reads the response from the shared response queue. However, if a response is not available in the shared response queue, after spinning for some time the thread goes into a sleep state. We maintain the status of the thread as \texttt{SLEEPING} or \texttt{RUNNING} in the shared data structure. We use the atomic variables to save the state of the thread avoiding race conditions. 
\\[3mm]
Obviously, a thread shouldn't sleep unless it is assured that somebody else, somewhere, will wake it up. The code doing the waking up job must also be able to identify the thread to be able to do its job. We use a linux data structure called \texttt{wait queue} to find the sleeping thread. Wait queue is a list of threads, all waiting for a specific event\cite{Galvin, Bovet:2005:ULK:1077084}. We initialize the wait queue for read response thread during an initialization stage of communication module in the application domain. The read response thread sleeps on the wait queue, waiting for a flag denoting the availability of the response to be set. The communication module in the driver domain checks the status of the read response thread after pushing responses on the shared response queue. If the status is \texttt{SLEEPING} then it sends a software interrupt through the event channel.
\\[3mm]
Similar to the base IDDR system, we create a new event channel in the initialization stage of the communication module in the application domain. We attach an interrupt handler routine for the event channel in the application domain. In the interrupt handler, the communication module wakes up the read response thread if sleeping. 

\item Read request thread in the driver domain:
In the new IDDR system, we create a kernel thread \textit{read request thread} during an initialization stage of the communication module in the driver domain. The thread spins to check if requests are available in the shared request queue. If a request is available, it reads the request from the shared request queue. However, if a request is not available in the shared request queue, the thread goes into a sleep state after spinning for some time (adaptive spinning). Similar to the read response thread, we maintain the status of the thread as \texttt{SLEEPING} or \texttt{RUNNING} as a atomic variable in the shared data structure. 
\\[3mm]
We initialize a wait queue for read request thread during an initialization stage of communication module in the driver domain. The read request thread sleeps on the wait queue, waiting for a flag denoting availability of the request to be set. The communication module in the application domain checks the status of the read request thread after pushing requests on the shared request queue. If the status is \texttt{SLEEPING} then it sends a software interrupt through event channel.
\\[3mm]
Similar to the base IDDR system, the driver domain connects to the event channel created by the application domain in the initialization stage of the communication module. We attach an interrupt handler routine for the event channel in the application domain. In the interrupt handler, the communication module wakes up the read request thread if sleeping. 
\end{itemize}

\subsection{Application Domain}

Application domain is the domain running user applications and the Linux kernel. In a Linux system, usually, an user process sends the read write request to file system, which sends the read and write request to the block device driver. The block device driver serves the request and sends back a response to the file system, which further sends the response to the user process. 
\\[3mm]
In the IDDR system implementation block device runs separately in the driver domain. When a user process sends a request to the file system, the file system needs to forward the request to the driver domain. Like explained in the section~\ref{subsec:frontend}, in the IDDR system, a piece of code called the frontend driver forwards the request to the driver domain running the block device driver. 

\subsubsection*{Base IDDR System}
The core responsibility of the front end driver in the base IDDR system is:
\begin{enumerate}
\item Provide an interface which appears as a block device to the upper layer in the stack.
\item Accept a request from the upper layer.
\item Create a corresponding new request which can be understood by the driver domain.
\item End the request after reading the response.
\end{enumerate}

Implementation details of front end driver can be split into 3 stages. 
\begin{enumerate}
\item Initialization
\item Submit request to the communication module
\item End request
\end{enumerate}

\paragraph{Initialization}
During the initialization, the frontend driver creates separate interface for each block device. The interface for each block device is associated with a device driver queue. Read and write requests issued on the interface gets enqued in this device driver queue.

\paragraph{Dequeue and Submit Request}
The frontend driver removes the request submitted to the driver interface and converts the request into a request structure which is understood by the backend driver. The new request structure points to the shared memory allocated for the read/write data by the communication module. The frontend driver then forwards the newly created request to the communication module, which shares the request with the backend driver further.

\paragraph{End Request}
We maintain an shadow table of all requests which were recieved in the device driver queue. The shadow table is a table which contains an entry of all the requests received. We implement the shadow table as a circular array of the requests. We maintain an ID for each request. The backend driver copies this ID into the corresponding response. The ID is used for mapping the response to the request in the shadow table. When a response is read by the communication module, it forwards the response to the frontend driver. The frontend driver searches the corresponding request in the shadow table, and ends it. 

\subsubsection*{New IDDR System}
The core responsibility of the frontend driver in the new IDDR system is:
\begin{enumerate}
\item Provide an interface for each block device.
\item Accept a request from the upper layer.
\item Create a corresponding new request which can be understood by the driver domain.
\item Spin for a short time for the reponse
\item End the request.
\end{enumerate}

Implementation details of front end driver is split into 4 stages. 
\begin{enumerate}
\item Initialization
\item Submit request to the communication module
\item Spinning the main thread
\item End request
\end{enumerate}

\paragraph{Initialization}
Similar to the base IDDR system, during the initialization process the frontend driver creates an interface for each block device.

\paragraph{Dequeue and Submit Request}
Similar to the base IDDR system, the frontend driver removes the request submitted to the driver interface and converts it into the request structure with a data pointer pointing to the shared memory. The frontend driver then forwards the newly created request to communication module, which shares the request with the backend driver further.

\paragraph{Spinning The Main Thread}
In the new IDDR system, to avoid the intra-domain context switch between the read response thread and the main frontend driver thread, the main frontend driver thread spins for a short time and checks the availability of a response. If the response is available then the frontend driver main thread reads the response and proceeds to end the request. Otherwise it continues to remove the request from the device driver queue.

\paragraph{End Request}
Similar to the base IDDR system, we maintain an shadow table of all requests recieved in the frontend driver request queue. The shadow table is used for ending the corresponding request of the read response. 

\subsection{Driver Domain}
The IDDR system runs a block device driver in the driver domain. Like explained in Section~\ref{subsec:backend}, a piece of code called backend driver runs in the driver domain which accepts requests from the application domain and forwards requests to the device driver. Upon receiving a response from the device driver, the backend driver sends back the response to the communication module.

\subsubsection*{Backend Driver}
The role of the backend driver in the IDDR system is :
\begin{enumerate}
\item Read request through communication module and convert it to the bio request.
\item Accept a response from the block device driver.
\item Forward the response to the communication module
\end{enumerate}

Implementation details of back end driver can be split into 5 stages. 
\begin{enumerate}
\item Convert a request to the bio request. 
\item Make a response.
\end{enumerate}

\subsubsubsection*{Convert A Request to bio}
\label{subsec:createbio}
The backend driver converts a request shared through the communication module into a bio request, so that the block device understands the request. In order to make the bio request, pages from the shared memory are mapped and inserted into the bio structure and required information is copied from the shared request into the bio structure. At the end, the newly created bio request is sent to the lower layer for the execution. Once bio request execution is completed, the system calls a callback function.

\subsubsubsection*{Make A Response and Enqueue}
Irrespective of the success or failure of the execution of bio request, the backend driver makes a response in the callback function. In this callback function the result of the bio execution and a request ID is copied into a newly allocated response structure. The request ID is used as the index in the shadow table to map a response and a request. The communication module pushes the response in to the shared response queue.

% \bibliography{references}
\ifbool{toShowBibliography}{\bibliography{references}}{}